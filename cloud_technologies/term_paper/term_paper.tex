\documentclass{article}

%-----------------------------------------------PACKAGES-------------------------------------------------------------%
\usepackage{graphicx} %images
\DeclareGraphicsExtensions{.pdf,.png,.jpg} % configures latex to look for the following image extensions
\usepackage{setspace} % allows for configuring the linespacing in the document
\usepackage{caption}
\usepackage{natbib}
\usepackage{appendix}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[explicit]{titlesec}
\usepackage{setspace} 
\onehalfspacing
\usepackage{hyperref}
\usepackage{url}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage[parfill]{parskip}
\usepackage{listings}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\bibliographystyle{agsm}
\setcitestyle{authoryear,open={(},close={)}}

%-----------------------------------------------#########--------------------------------------------------------------%


%PREAMBLE
\author{Stephen Coady}
\onehalfspacing

%CONTENT
\begin{document}
\include{components/title}
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\newpage
\section{Introduction} %REVIEW Not overly happy with this, needs refining and improving.
\label{sec:Introduction}
Modern applications are becoming increasingly complex, meaning it can also be complex to deploy the application. This research paper will examine application deployment, and will aim to show how modern tools and technologies can be used to simplify the process of building and deploying an application to the cloud. 

It will compare these tools with ``legacy'' processes, evaluating the strengths and weaknesses of both. It will do this under the premise of a problem domain, discussed in Section \ref{sec:Problem}.

Not only is application deployment a problem, but provisioning the servers which the application is hosted on is also something which needs to be considered. This paper will look at the automation of this process.

\section{Problem Domain}
\label{sec:Problem}

A fitting definition of DevOps is ``\textit{DevOps is the practice of operations and development engineers participating together in the entire service lifecycle, from design through the development process to production support}'' \citep{devops}.

Here the ``service lifecycle'' is the key term, as it means everything involved in creating a service and making it available for use in production. In older legacy systems the process would have involved separate teams performing each task along this timeline separately and without much overlap of personnel. In a simplified version of this model, the developers would write the code, the testers would test it, and the operations personnel would then deploy it along with provisioning the servers it would be deployed on.

This model however has shifted. In a survey conducted by \citep{survey}, it is shown that, in general, DevOps orientated teams spend slightly more time on \textit{all} tasks, whereas traditional IT roles will focus more on their primary tasks. This puts emphasis on the fact that developers now need to be more competent at multiple disciplines within IT. This, paired with the fact that the survey also shows DevOps orientated teams tend to automate more, shows that the importance of automated deployments has increased in recent times. 

Also, with the rise in popularity of containers as a deployment vehicle, as can be seen for Docker specifically in Figure \ref{fig:datadog} it is more and more important to make the deployment of complicated applications more streamlined and reproducible.

To this end, this paper will aim to propose a solution to the problem of provisioning a production server and then deploying a fault-tolerant, scalable application to the server. It will try to show how the process of building infrastructure and deploying an application to that infrastructure can be automated, increasing productivity and also allowing for an easily reproducible environment.

\begin{figure}[!h]
\centering
\includegraphics*[width=1\textwidth]{components/images/datadog}
\caption{\em Rise in Docker Usage. Credit: \citep{datadog}}
\label{fig:datadog}
\end{figure}
 
\newpage
\section{Technology Background}
\label{sec:Background}

In this chapter we will examine a number of technologies that together will aim to solve the problem discussed in Section \ref{sec:Problem}.

\subsection{Containers} %REVIEW need to talk about cgroups and namespaces
\label{sub:Containers}
In software, a container is a process isolated from the host which generally runs in a very lightweight wrapper. It uses the underlying Linux kernel to do the work it needs to but ultimately it is a separate process which is self-contained \citep{Matthias2015}. They contain complete filesystems which can house everything the packaged application needs to run, including code, environment variables, libraries and dependencies.

Containers are often compared with virtual machines, however this view is a bit simplistic. Virtual machines are fully fledged operating systems running on a hypervisor which emulates dedicated hardware. It is made up of virtual devices which emulate the physical devices of a real host. Containers however, are not as full featured. Instead, they can be made so that they only have those resources that they need - and nothing else. So while virtual machines are emulating a real server, it could be said that a container is emulating a single \textit{process} on a server - and only packaging exactly what that process needs to run.

\paragraph{Advantages}\mbox{}\\
Some advantages of containers are:

\begin{itemize}
  \item Lightweight - images can be as small as 15 MB
  \item Ephemeral - containers lifespan can be as small as is needed, they can be started to perform a single process and then stop as soon as they are done. 
  \item Cheap - it is not CPU intensive to start a container
  \item Portable - containers can be built from a single file
  \item Secure - Using containers ensures applications are isolated from each other. An added benefit here is that multiple versions of the same application be running on the same host.
\end{itemize}

\paragraph{Disadvantages}\mbox{}\\

There can also be drawbacks to containers, these include:

\begin{itemize}
  \item Potential for added work - while containers can be useful they can also add to the work load and increase the lifecycle management of the application infrastructure.
  \item Orchestrating large applications can be complex
  \item The containers share the same kernel. Any issues with the kernel and the container engine running on it will affect all containers.
\end{itemize}

\subsection{Docker}
\label{sub:Docker}

\subsubsection{Swarm}
\label{subs:Swarm}

\subsubsection{Alternatives}
\label{subs:Docker-alt}


\subsection{Ansible}
\label{sub:Ansible}

\subsubsection{Alternatives}
\label{subs:Ansible-alt}

\subsection{Amazon Web Services}
\label{sub:AWS}

\subsubsection{Alternatives}
\label{subs:AWS-alt}


\newpage
\section{Building an Application}
\label{sec:Build}

\newpage
\section{Conclusion}
\label{sec:Conclusion}

\newpage
\bibliography{references}


\end{document}
