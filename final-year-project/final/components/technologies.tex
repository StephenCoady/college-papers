% !TEX root = ../final_report.tex
\section{Technologies}
\label{sec:technologies}
In this section of the report the technologies used to create the application will be examined and explained in detail.
\subsection{Docker}
\gls{Docker} is a platform which allows developers to package their applications into isolated containers which contain only the software dependencies required by the application. A container is different to a \gls{VM} in that a container does not contain a full operating system \citep{WhatDocker}.

Since a primary objective of this application is to manage a \gls{Docker host} it makes sense to leverage the capabilities of Docker and run this application within a \gls{Docker container}. This provides several benefits over distributing source code, such as:

\begin{itemize}
	\item Portability - If a \gls{Docker image} can be built and uploaded to a public repository then it makes it easier for other developers to pull and run the application.
	\item Ease of use - As the application will be running in a container a developer does not need to install any third party components on their system to use the application. They do not need to worry about their environment as once their system has Docker installed it will run the application.
	\item Ephemeral - Docker containers are designed to be `throw-away'. This means that if this application needs to be quickly stopped and restarted then containers are the perfect vehicle to do this.
\end{itemize}

\subsection{Node JS}
\label{sub:nodejs}
Node JS is a server-side JavaScript runtime, it is built on the same V8 engine that powers the popular Chrome browser. It uses an event-driven, non-blocking I/O model that makes it lightweight, efficient and very fast. Node JS' package ecosystem, NPM, is the largest ecosystem of open source libraries in the world \citep{Nodejs.org2016}. Node JS provides an excellent way to build highly scalable network application which are non-blocking and extremely performant \citep{Griffin2011}. This means that if the application was adapted in the future to deal with large numbers of servers then the technology choice will be able to deal with that.

Node JS was also deemed a good fit for this project as it has a large and extremely active online community. Since this is an open source project this will increase the likelihood of other developers taking part in the project and contributing. We can see in Figure \ref{fig:counts} that there are currently (as of November 2016) more node modules available through the node package manager (NPM) than any other of the large package managers such as the ones used by Go, PHP, Python and Ruby. 
\newpage
\begin{figure}[!ht]
\centering
\includegraphics*[width=0.8\textwidth]{images/module_counts}
\caption{\em Various Module Counts (Credit: modulecounts.com)}
\label{fig:counts}
\end{figure}

The original idea for this project also came from the Red Hat Mobile Application which is a node-based project built using a large amount of Docker images \citep{RedHat2016}. Therefore it made sense to align this technology stack with this project.

\subsection{Angular JS}
Angular JS is a web framework for building dynamic web applications using Javascript as a controller. It uses HTML as its template language to display the information passed to it from the application controller \citep{Angular2017}. 

For this application the front end requirements were relatively low. Once the framework provided a mechanism to show dynamic content then it was a candidate. For this reason several were evaluated and Angular was chosen as it had the lowest barrier to entry. The front-end application will be discussed further in Section \ref{sec:design}.

One requirement when choosing the front end framework was that it was modular. If, at some point in the future, this project required a new front end framework for some unknown feature then it must be relatively easy to remove Angular and use the new feature. This is discussed further in Section \ref{sub:front-end}.

\subsection{Travis CI}
Since this project was developed as an open source project it made sense to have a transparent and fully automated build process integrated into the project. For this reason \gls{ci} and \gls{cd} in this project is handled by \gls{Travis} CI. It is a feature-rich service free to use for open source projects and has a large user base. The set up used in this project for testing and continuous integration and deployment will be explored further in Section \ref{sec:methodology}. The Travis repository for this application is available in Appendix \ref{appendix:travis}.

\subsection{SonarQube}
\label{sub:sonarqube-technologies}
In general all projects tend to take shortcuts to solve problems. This is particularly true for a final year project where the student must balance developing a substantial code base alongside other modules. This can mean that the final product of many final year projects can suffer performance issues and still be working software. In industry \gls{technical debt} is a huge problem as it accrues over time and must be paid off in the long run. It can become so ingrained that it can be almost impossible to refactor out of the code without huge cost, either time or financial. With this in mind all code in this project is held to a high standard. From the very beginning this project will aim to be a performant, reusable and readable system that other developers can use without confusion.

To achieve this an open source tool \gls{sonarqube} will be used \citep{Sonar2016}. This tool analyses the output of tests to give detailed information about test coverage and it also scans the code to find possible bugs and \gls{code smell}s. It can give useful information such as the current amount of \gls{technical debt}. SonarQube will be discussed in further detail in Section \ref{sub:code_quality}. The SonarQube repository for this project can be seen in Appendix \ref{appendix:sonarqube}.

\subsection{Vagrant}
\label{sub:vagrant}
Vagrant is a technology to create configurable, reproducible and portable environments by using a set of programmable steps to produce a \gls{VM} which the developer can use to develop in \citep{Vagrant2017}. While this is just one use-case of Vagrant it is the main reason it was used in this project. 

Since this project is open source it is useful to have one standardised VM within which all development can take place. This virtual machine can then be shared (either as its own separate repository or included in the main application repository). This is useful as it enables any developer who wishes to contribute to the project to instantly have the required environment. For instance, a developer can contribute to this project by using the \gls{Vagrantfile} supplied without requiring them to first install Docker or Node JS.
